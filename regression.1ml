Equivalence: {
  type t a b;

  transitivity 'a 'b 'c: t a b => t b c -> t a c;
  reflexivity 'a: t a a;

  symmetry 'a 'b: t a b -> t b a;

  to   'a 'b: t a b => a -> b;
  from 'a 'b: t a b => b -> a;
} = {
  type T a b = (type p _) -> p a -> p b;
  type t a b = wrap T a b;
  wr (eq: T _ _) = wrap eq: t _ _;
  un eq = unwrap eq: t _ _;
  transitivity 'a 'b 'c (ab: t a b) (bc: t b c) =
    wr (fun (type p _) => un bc p << un ab p);
  reflexivity = wr (fun (type p _) => id);
  to eq a = un eq (fun (type x) => x) a;
  from 'a 'b (eq: t a b) b = un eq (fun (type b) => type b -> a) id b;
  symmetry 'a 'b (eq: t a b) : t b a =
    wr (fun (type p _) => un eq (fun (type b) => type p b -> p a) id);
};

Hungry = {
  type eat a = rec eat_a => a -> eat_a;

  eater 'a: eat a = rec (eater: eat a) => @(eat a) (fun a => eater);

  (<+) eater x = eater.@(eat _) x;

  do eater <+ 1 <+ 2;
};

PolyRec = {
  type l a = rec (type t) => alt a t;
  t = rec (type t a) => fun (type a) => alt a (t (type (a, a)));

  t_int = t int;

  hmm (x: t int) = casealt (x.@(t int));

  t0 = @(t int) (right (@(t (type (int, int))) (left (0, 0))));
};
