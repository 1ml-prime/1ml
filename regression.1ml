Equivalence: {
  type t a b;

  transitivity 'a 'b 'c: t a b => t b c -> t a c;
  reflexivity 'a: t a a;

  symmetry 'a 'b: t a b -> t b a;

  to   'a 'b: t a b => a -> b;
  from 'a 'b: t a b => b -> a;
} = {
  type T a b = (type p _) -> p a -> p b;
  type t a b = wrap T a b;
  wr (eq: T _ _) = wrap eq: t _ _;
  un eq = unwrap eq: t _ _;
  transitivity 'a 'b 'c (ab: t a b) (bc: t b c) =
    wr (fun (type p _) => un bc p << un ab p);
  reflexivity = wr (fun (type p _) => id);
  to eq a = un eq (fun (type x) => x) a;
  from 'a 'b (eq: t a b) b = un eq (fun (type b) => type b -> a) id b;
  symmetry 'a 'b (eq: t a b) : t b a =
    wr (fun (type p _) => un eq (fun (type b) => type p b -> p a) id);
};

;;

Pure : () => {type t = bool; existentials: t} = fun () =>
  {type t = bool; existentials = false} :> {type t = bool; existentials: t};

;; Impure : () => {type t; existentials: t} = fun () =>
;;   {type t = bool; existentials = true} :> {type t = bool; existentials: t};

;;

Hungry = {
  type eat a = rec eat_a => a -> eat_a;

  eater 'a: eat a = rec (eater: eat a) => @(eat a) (fun a => eater);

  (<+) eater x = eater.@(eat _) x;

  do eater <+ 1 <+ 2;
};

PolyRec = {
  type l a = rec (type t) => alt a t;
  t = rec (type t a) => fun (type a) => alt a (t (type (a, a)));

  t_int = t int;

  hmm (x: t int) = casealt (x.@(t int));

  t0 = @(t int) (right (@(t (type (int, int))) (left (0, 0))));
};

N :> {
  type Z;
  type S _;
} = {
  type Z   = {};
  type S _ = {};
};

ListN = let
  type I (type x) (type p _ _) (type t _ _) = {
    nil     :               p x N.Z;
    (::) 'n : x -> t x n -> p x (N.S n);
  };
  type T x n (type t _ _) = (type p _ _) => I x p t -> p x n;
in {
  t = rec (type t _ _) => fun (type x) (type n) => type wrap T x n t;

  case 'x 'n (p: {type t _ _}) (cs: I x p.t t) e =
    (unwrap e.@(t _ _): wrap T x n t) p.t cs;

  local
    mk 'x 'n (c: T x n t) = @(t x n) (wrap c: wrap T x n t);
  in
    nil  'x                       = mk (fun (type p _ _) (r: I x p t) => r.nil);
    (::) 'x 'n (v: x) (vs: t x n) = mk (fun (type p _ _) (r: I x p t) => r.:: v vs);
  end;
} :> {
  type t _ _;

  case 'x 'n: (p: {type t _ _}) => I x p.t t => t x n -> p.t x n;

  nil  'x    :               t x N.Z;
  (::) 'x 'n : x => t x n => t x (N.S n);
};

ListN = {
  ...ListN;
  map 'x 'y 'n (xy: x -> y) = rec (map: 'n => t x n -> t y n) =>
    case {type t _ n = t y n} {
      nil = nil;
      (::) x xs = xy x :: map xs;
    };
};
