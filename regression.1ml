Equivalence: {
  type t a b;

  transitivity 'a 'b 'c: t a b => t b c -> t a c;
  reflexivity 'a: t a a;

  symmetry 'a 'b: t a b -> t b a;

  to   'a 'b: t a b => a -> b;
  from 'a 'b: t a b => b -> a;
} = {
  type T a b = (type p _) -> p a -> p b;
  type t a b = wrap T a b;
  wr (eq: T _ _) = wrap eq: t _ _;
  un eq = unwrap eq: t _ _;
  transitivity 'a 'b 'c (ab: t a b) (bc: t b c) =
    wr (fun (type p _) => un bc p << un ab p);
  reflexivity = wr (fun (type p _) => id);
  to eq a = un eq (fun (type x) => x) a;
  from 'a 'b (eq: t a b) b = un eq (fun (type b) => type b -> a) id b;
  symmetry 'a 'b (eq: t a b) : t b a =
    wr (fun (type p _) => un eq (fun (type b) => type p b -> p a) id);
};

Hungry = {
  type eat a = rec eat_a => a -> eat_a;

  eater 'a: eat a = rec (eater: eat a) => @(eat a) (fun a => eater);

  (<+) eater x = eater.@(eat _) x;

  do eater <+ 1 <+ 2;
};

PolyRec = {
  type l a = rec (type t) => alt a t;
  t = rec (type t a) => fun (type a) => alt a (t (type (a, a)));

  t_int = t int;

  hmm (x: t int) = casealt (x.@(t int));

  t0 = @(t int) (right (@(t (type (int, int))) (left (0, 0))));
};

N :> {
  type Z;
  type S _;
} = {
  type Z   = {};
  type S _ = {};
};

ListN = let
  type IMPURE (type x) (type p _ _) (type t _ _) = {
    nil     :               p x N.Z;
    (::) 'n : x -> t x n -> p x (N.S n);
  };
  type PURE (type p _ _) (type t _ _) = {
    nil  'x    :               p x N.Z;
    (::) 'x 'n : x => t x n => p x (N.S n);
  };
in {
  t = rec (type t _ _) =>
    fun (type x) (type n) => type wrap (type p _ _) => IMPURE x p t -> p x n;
  mk 'x 'n (fn: (type p _ _) => IMPURE x p t -> p x n) =
    @(t x n) (wrap fn: wrap (type p _ _) => IMPURE x p t -> p x n);
  nil 'x = mk (fun (type p _ _) (r: IMPURE x p t) => r.nil);
  (::) 'x 'n (v: x) (vs: t x n) =
    mk (fun (type p _ _) (r: IMPURE x p t) => r.:: v vs);
  case 'x 'n (p: {type t _ _}) (cs: IMPURE x p.t t) e =
    (unwrap e.@(t _ _): wrap (type p _ _) => IMPURE x p t -> p x n) p.t cs;
} :> {
  type t _ _;
  ...PURE t t;
  case 'x 'n: (p: {type t _ _}) => IMPURE x p.t t => t x n -> p.t x n;
};

ListN = {
  ...ListN;
  map 'x 'y 'n (xy: x -> y) = rec (map: 'n => t x n -> t y n) =>
    case {type t _ n = t y n} {
      nil = nil;
      (::) x xs = xy x :: map xs;
    };
};
