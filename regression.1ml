local import "basis"

;;

record_inference x = x.works_a_little

;;

conditionals b : int =
  if b then print "then1" else print "else1"
  print "between"
  if not b then
    print "then2"
    if b then print "then3"
  else print "else2"
  101

aType i =
  if i == 0 then int
  else if i == 1 then text
  else char : type

;;

type DEC_PUNNING = {int, list}

;;

Equivalence: {
  type t a b

  transitivity 'a 'b 'c: t a b -> t b c -> t a c
  reflexivity 'a: t a a

  symmetry 'a 'b: t a b -> t b a

  to   'a 'b: t a b -> a ~> b
  from 'a 'b: t a b -> b ~> a
} = {
  type T a b = (type p _) ~> p a ~> p b
  type t a b = wrap T a b
  wr (eq: T _ _) :# t _ _ = eq
  un (eq :# t _ _) = eq
  transitivity 'a 'b 'c (ab: t a b) (bc: t b c) =
    wr fun (type p _) => un bc p << un ab p
  reflexivity = wr fun (type p _) => id
  to eq a = un eq (type fun x => x) a
  from 'a 'b (eq: t a b) b = un eq (type fun b => b ~> a) id b
  symmetry 'a 'b (eq: t a b) : t b a =
    wr fun (type p _) => un eq (type fun b => p b ~> p a) id
}

;;

AmateurOptics = {
  type FUNCTOR = {
    type t a
    map 'a 'b: (a ~> b) -> t a ~> t b
  }

  type lens a b s t = (F: FUNCTOR) -> (a ~> F.t b) -> s ~> F.t t

  ;; NOTE: It is important that the following do not have more type annotations,
  ;; because the bug that this triggered was due to treatment of inferred types.

  ((l1: lens _ _ _ _) <-< (l2: lens _ _ _ _)) (F: FUNCTOR) toF = l1 F (l2 F toF)

  e1 (F: FUNCTOR) abF (l, r) = F.map (fun l => (l, r)) (abF l)

  e11 = e1 <-< e1
}

;;

brace_style_1 = {x = 1, y = 2}
brace_style_2 = {
  x = 1
  y = 2
}
brace_style_3 =
  {
    x = 1
    y = 2
  }

seq_exps x : (_, _) =
  Int.print x
  let x v = v + 1
      y = x 1 + 1
  Int.print (y, y).1 : {}
  Int.print (x 0)
  let z x = Int.print x ; x + 1
  Int.print (z 1)
  (
    let x = 1, y = 2
    x + y,
    Int.print 10; 1
  )

Control = {
  ifElse cond onT onF = if cond then onT () else onF ()

  do ifElse true
       fun {} => 101
       fun {} => 42
}

Monadic = {
  type MONAD = {
    type t _
    of 'x: x ~> t x
    chain 'x 'y: (x ~> t y) -> t x ~> t y
  }

  Ops (M: MONAD) = {
    ...M
    xM >>= xyM = chain xyM xM
    xM >> yM = xM |> chain fun {} => yM
  }

  monadic (M: MONAD) = let ...Ops M
    of 101 >>= fun x =>
    of {} >>
    of x
}

;;

hole_is_allowed_type_pattern (type _ _) = ()

typparams_allowed (id 'a: a -> a) ({alsoId 'x: x -> x}) =
  alsoId (id 1, id "one", alsoId true)

;;

do {{id} = {id x = x}, do id: _ -> _}

type_error {
  {} = "not a structure"
}

type_error {
  inconsistent_empty_and_annpat ({}: int) = ()
}

type_error {
  inconsistent_nested_annpats ((x: int): text) = ()
}

Both = {
  ({x, y = _} as {x = _, y}) = {x = 1, y = 2}
}

;;

type_error { type_error 101 }

;;

type_error {
  Impure : () -> {type t} = fun () =>
    if true then {type t = int} else {type t = bool} : {type t}
}

ImpureIf : () ~> {type t} = fun () =>
  if true then {type t = int} else {type t = bool} : {type t}

PureIf : () -> ('a -> a -> a) = fun () =>
  if true then id else id : 'a -> a -> a

Pure : () -> {type t = bool, existentials: t} = fun () =>
  {type t = bool, existentials = false} :> {type t = bool, existentials: t}

type_error {
  Impure : () -> {type t, existentials: t} = fun () =>
    {type t = bool, existentials = true} :> {type t = bool, existentials: t}
}

;;

type_error rec (R: {}) => {
  kaboom () = R
}

Kaboom = rec (R: rec R => {kaboom: () ~> R}) :@ (= R) => {kaboom () = R}

;;

Mutually = let
  T = rec (R: {
    Even: {type t _}
    Odd: {type t _}
  }) => {
    Even = {
      type t x = {head: x, tail: R.Odd.t x}
    }
    Odd = {
      type t x = opt (R.Even.t x)
    }
  }
in {
  ...rec (R: {
    Even: {
      size 'x: T.Even.t x ~> int
    }
    Odd: {
      size 'x: T.Odd.t x ~> int
    }
  }) => {
    Even = {
      ...T.Even
      make 'x (head: x) (tail: T.Odd.t x) :@ T.Even.t x =
        {head, tail}
      size 'x (v :@ T.Even.t x) = 1 + R.Odd.size v.tail
    }
    Odd = {
      ...T.Odd
      make 'x (v: opt (T.Even.t x)) :@ T.Odd.t x = v
      size 'x (v :@ T.Odd.t x) =
        v |> Opt.case {
          none = 0
          some e = R.Even.size e
        }
    }
  }

  one = Odd.size (Odd.make (some (Even.make true (Odd.make none))))
}

;;

Alt = {
  ...Alt
  type a | b = alt a b
} : {
  ...(= Alt)
  type _ | _
}
(|) = Alt.|

type AnAlt = {x: int} | {y: bool}

infix_type_pat 'a 'b (type _ | _) (x: a | b) = x
infix_type_dec 'a 'b ({type _ | _}) (x: a | b) = x

type infix_tycon_param a b = (type _ <+> _) -> a <+> b

type (a `>>` b) c = c

;;

AnnotRecType = {
  t = type rec (type t x) : type -> type => fun x => (x, t x)
}

Hungry = {
  type eat a = rec eat_a => a ~> eat_a

  eater 'a = rec (eater: eat a) :@ eat a => fun a => eater

  (eater :@ eat _) <+ x = eater x

  do eater <+ 1 <+ 2
}

PolyRec = {
  type l a = rec (type t) => a | t
  ...rec {type t a} => {type t a = a | t (a, a)}

  t_int = t int

  hmm (x :@ t int) = flip Alt.case x

  t0 = inr (inl (0, 0) :@ t (int, int)) :@ t int
}

N :> {
  type Z
  type S _
} = {
  type Z   = {}
  type S _ = {}
}

ListN = let
  type I (type x) (type p _) (type t _ _) = {
    nil     :               p N.Z
    (::) 'n : x ~> t x n ~> p (N.S n)
  }
  type T x n (type t _ _) = (type p _) -> I x p t ~> p n
in {
  ...rec {type t _ _} => {type t x n = wrap T x n t}

  case 'x 'n (type p _) (cs: I x p t) (e :# wrap T x n t :@ t x n) =
    e p cs

  let mk 'x 'n (c: T x n t) = c :# wrap T x n t :@ t x n in {
    nil  'x                     = mk fun (type p _) (r: I x p t) => r.nil
    'x (v: x) :: 'n (vs: t x n) = mk fun (type p _) (r: I x p t) => r.:: v vs
  }
} :> {
  type t _ _

  case 'x 'n: (type p _) -> I x p t -> t x n ~> p n

  nil  'x    :               t x N.Z
  (::) 'x 'n : x -> t x n -> t x (N.S n)
}

ListN = {
  ...ListN
  map 'x 'y (xy: x ~> y) = rec (map 'n: t x n ~> t y n) =>
    case (t _) {
      nil
      x :: xs = xy x :: map xs
    }
}
