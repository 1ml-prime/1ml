type bool = primitive "bool";
type int  = primitive "int";
type text = primitive "text";

true = primitive "true" ();
false = primitive "false" ();
equal = primitive "==";
(+) = primitive "+";
(-) = primitive "-";

type OPT =
{
  type opt a;
  none a : opt a;
  some a : a -> opt a;
  caseopt a b : opt a -> b -> (a -> b) -> b;
};

Opt :> OPT =
{
  type opt a = (b : type) => b -> (a -> b) -> b;
  none a b (n : b) (s : a -> b) = n;
  some a (x : a) b (n : b) (s : a -> b) = s x;
  caseopt a b (xo : opt a) = xo b;
};
Opt' :> OPT =  ;; alternative implementation
{
  type opt' a = (b : type) => b -> (a -> b) -> b;
  type opt a = pack opt' a;
  type t a = opt a;
  none a = pack (fun b (n : b) (s : a -> b) => n) : opt' a;
  some a (x : a) = pack (fun b (n : b) (s : a -> b) => s x) : opt' a;
  caseopt a b (o : opt a) = (unpack o : opt' a) b;
};
include Opt;

type LIST =
{
  type list a;
  nil a : list a;
  cons a : a -> list a -> list a;
  caselist a b : list a -> b -> (a -> list a -> b) -> b;
  isNil a : list a -> bool;
  head a : list a -> opt a;
  tail a : list a -> opt (list a);
  length a : list a -> int;
  cat a : list a -> list a -> list a;
  rev a : list a -> list a;
  nth a : list a -> int -> opt a;
  map a b : list a -> (a -> b) -> list b;
  foldl a b : list a -> b -> (b -> a -> b) -> b;
  foldr a b : list a -> b -> (a -> b -> b) -> b;
};

List :> LIST =
{
  type list a = (b : type) => b -> (a -> b -> b) -> b;
  nil a b (n : b) (c : a -> b -> b) = n;
  cons a (x : a) (xs : list a) b (n : b) (c : a -> b -> b) = c x (xs b n c);
  foldr a b (xs : list a) = xs b : b -> (a -> b -> b) -> b;
  isNil a (xs : list a) =
    foldr a bool xs true (fun (_ : a) (_ : bool) => false);
  head a (xs : list a) =
    foldr a (opt a) xs (none a) (fun (x : a) (_ : opt a) => some a x);
  tail a (xs : list a) =
    let type t = (list a, opt (list a)) in
    foldr a t xs
      (nil a, none (list a))
      (fun (x : a) (acc : t) => (cons a x (acc.1), some (list a) (acc.1)))
    .2;
  caselist a b (xs : list a) (n : b) (c : a -> list a -> b) =
    caseopt a b (head a xs)
      n
      (fun (x : a) => caseopt (list a) b (tail a xs)
        n
        (fun (xs' : list a) => c x xs));
  length a (xs : list a) =
    foldr a int xs 0 (fun (_ : a) (n : int) => n + 1);
  cat a (xs1 : list a) (xs2 : list a) =
    foldr a (list a) xs1 xs2 (cons a);
  rev a (xs : list a) =
    foldr a (list a) xs (nil a)
      (fun (x : a) (xs : list a) => cat a xs (cons a x (nil a)));
  map a b (xs : list a) (f : a -> b) =
    foldr a (list b) xs (nil b) (fun (x : a) => cons b (f x));
  foldl a b (xs : list a) (x : b) (f : b -> a -> b) =
    foldr a b (rev a xs) x (fun (x : a) (y : b) => f y x);
  nth a (xs : list a) (n : int) =
    let (==) = equal int in
    foldr a (type (int, opt a)) xs (length a xs - 1, none a)
      (fun (x : a) (p : (int, opt a)) =>
        (p.1 - 1, if p.1 == n then some a x else p.2 : opt a))
    .2;
};
include List;


type ORD =
{
  type t;
  (<=) : t -> t -> bool;
};

type SET =
{
  type set;
  type elem;
  type t = set;
  empty : set;
  add : elem -> set -> set;
  mem : elem -> set -> bool;
  card : set -> int;
};

Set (Elem : ORD) :> SET with elem = Elem.t =
{
  type elem = Elem.t;
  type set = (int, elem -> bool);
  type t = set;
  (==) = equal elem;
  empty = (0, fun (x : elem) => false);
  card (s : set) = s._1;
  mem (x : elem) (s : set) = s._2 x;
  add (x : elem) (s : set) =
    if mem x s then s
    else (s._1 + 1, fun (y : elem) => x == y or mem y s) : set;
};

type MAP =
{
  type map a;
  type key;
  type t a = map a;
  empty a : map a;
  add a : key -> a -> map a -> map a;
  lookup a : key -> map a -> opt a;
};

Map (Key : ORD) :> MAP with key = Key.t =
{
  type key = Key.t;
  type map a = key -> opt a;
  t = map;
  (==) = equal key;
  empty a (x : key) = none a;
  lookup a (x : key) (m : map a) = m x;
  add a (x : key) (y : a) (m : map a) (z : key) =
    if x == z then some a y else m x : opt a;
};
